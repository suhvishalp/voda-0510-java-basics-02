
10 - 11.15 / 11.30  - Session 1         - introduce new concepts

11.45 - 1.00        - Session 2         - continued discussions / demos on the topic of the day 

2.00 to 04.00       - session 3         - assignments / demos / self-study / practice / read 

4.00 to 06.00       - session 4         - q&a, project work



VM - 
Environment Setup 
---------------------
    - java 12
    - spring tool suite
    - node 
    - VS Code 
    - mysql community edition + mysql workbench (root)
    - docker 


Language                        Library                             Framework 

Java                            standard libraries                  Spring Framework
                                i.e. lang, io, jdbc, etc.
                                log4j, gson, junit, 


Python                          NumPy, Pandas                       Django, Flask

C/C++                           stdio.h, conio.h                    ...

JavaScript / TypeScript         JQuery, React                       NextJS, Angular, NuxtJS, NestJS

GoLang                          ----

C#/VB                           ---

    |                               |                                   |
programming                     Simply the tasks                    standardise the process 
capabilities     



NodeJS
    - execution env for js code 


Testing tools / libraries 

Package managers / Build tools
    - maven
    - gradle 

CICD tools 
    - jenkins 

VCS Tools 
    - git 
    - gitlab 




Java 
----------

    .java ----> java compiler -----------------------> .class 
                converts your javacode into ByteCode


    - ByteCode is understandable only to JVM

    JVM - Java Virtual Machine 
        - responsible to execute the bytecode on the given platform 

    JRE - Java Runtime Environment
        - JVM + standard libraries 

    JDK - Java Development Kit 
        - JRE + development tools i.e. javac, jar, etc. 


========================
Explore: 1. JVM Architecture 
            - Class Loader in JVM 
                    - loading, linking, initialization 
            - execution engine 

         2. Garbadge Collection 
            https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html#t2

         3. Naming Conventions 
            https://www.oracle.com/java/technologies/javase/codeconventions-introduction.html

        4. Data types, operators in java 

========================


    Java is a object oriented programming language 




    - Variables in java 
        - store values 

        1. Local Variables 
                - declared inside a method, constructor  
                - don't have default values, must be initialized before its use 
                - memory for all the local variables will be allocated when the method is invoked, and the detroyed when the method finishes its execution 


        2. Instance Variables 
                - declared inside a class, (outside methods)
                - whenever a new object is created (using 'new' keyword), memory for all the instance 
                    variables will be allocated, destroyed when the object is deleted 
                - instance variables have default values 
                    - i.e. for numbers = 0
                        for booleans = false 
                        for reference types = null 
                - we can use the access modifiers i.e. public, private, protected, default 

                        - defualt - the members will be accessible anywhere within the same 'package'
                        - public - accessible everywhere 
                        - private - accessible only within the class 
                        - protected - accessible only within the class and the subclass 

        3. Static Variables 
                - declared inside a class, using the 'static' keyword
                - only 1 copy of static variable will be allocated per class 
                - when the class is loaded, memory for static variables will be allocated 
                - define the accessiblity using the modifiers i.e. public, private, protected 


Garbadge Collection 
    - removes the unreferenced objects from the memory 


    static keyword 
        - static variables 

        - static methods 

        - static class 

    final keyword 
        - final variables
            - a final variable is constant variables, once the value is assigned you cannot change it  

        - final methods 
            - a final method cannot be overridden in its subclass 

        - final class 
            - a final class cannot be subclassed 


    Java Keyboard inputs 
    ------------------------

            1. using Scanner class 

            2. using IO classes 

            3. using Console class 



    Data types 
    ----------------
        primitive data types 
            - hold / represent values directly 

                byte        1 byte              -128 to 127

                short       2 bytes             ..

                int         4 bytes             ..

                long        8 bytes 

                float       4 bytes 

                double      8 bytes 

                char        1 byte 

                boolean     1 bit

        Refernece types 
            - all the class, interface, enums type variables are called reference types 
            - stores ref to the memory 

                String str; 
                Employee employee;


        Wrapper classes 
        --------------------
            - for each primitive type i.e. int, char etc. there is a corresponding reference type available i.e. Integer, Character 


                    byte                Byte 
                    short               Short 
                    int                 Integer 
                    long                Long 
                    float               Float 
                    double              Double 
                    char                Character 
                    boolean             Boolean 

            - wrapper classes provide various methods to perform typecasting, and a few operations 





    Common terms 
    -------------------------------------------

        POJO - plain old java object 
            - ordinary java classes 
            - simple class 
            - a class that doesn't 
                - extend to any other class 
                - contain any annotations 
                - implement any interface 


                public class Employee {

                }

        Java Beans 
            - it is special pojo class that has below requirements 
                - implements serializable 
                - all properties / instance variables are defined as private 
                - public getter/setter methods 
                - has a no-arg constructor 

            public class Employee implements serializable {

            }

        VO - value object 


        BO - Business object 
            - classes that represent business entities 

        SO - Service object 
            - classes represents code to perform some business operations 
            - business logic 

        DAO - Data access object    
            - classes represents code to perform db operations 
            - 

        DTO - Data transfer object 
            - used to represent the structure of data usually exchanged between client-servers 


        


        Spring Beans 


   ------------------------------------------- 



    Control statements 
        - if 

            if(boolean_expression){

            }

        - if - else 

            if(boolean_expression1){
                
            }else {

            }

            

        - if - else if - else 

            if(boolean_expression){
                
            }else if(boolean_expression2){

            }
            ..
            ..
            ..
            else {

            }


        - switch case statement 

            switch(expression){     //expression that evaluates to byte, short, int, char, or string 

                case constant1: 
                    statements;
                    statements;
                    break;

                case constant2: 
                    statements;
                    statements;
                    break;

                case constant3:
                    statements;
                    statements;
                    break;
                ..

                ..

                default :
                    statements;
                    statements;
                   
            }


    Looping statements 
        - while 
        - do while 
        - for 
        - enhanced for loop 

     



    Array 
    ---------
        - used to store fixed number of elements 
        - the size of array is fixed 
        - in java Array is an object 

        a. declare an array variable 

                <<data-type>>[] arr-var-name;
                int[] numbers;
                short[] nums;
                String[] names;
                double 

                String[] names;
                String [] names;
                String []names;
                String names[];


        b. create array object 

                arr-var-name = new <data-type>[size];
                numbers = new int[5];


        c. initialize values 

                numbers[0] = 10;
                numbers[1] = 20;
                numbers[2] = 30;


        int[] numbers = new int[5];

        int[] numbers = new int[] {21,54,34,54,76,45};




      java.util.Arrays class 
      -----------------------------
        - This class contains various methods for manipulating arrays (such as sorting and searching). This class also contains a static factory that allows arrays to be viewed as lists.


    Java OOPS 
    ----------------

        Encapsulation 
            - binding data & logic together 

        Abstraction 
            - hiding the complexities from outside world 
            - hide unnecessary details from the outside world 

        Inheritance 
            - a class can be derived from another class 
            - the members of the parent class are inherited by the child class 
            - reusability 
            - maintainability 
            - extendibility 

                        class Person {
                            String name;
                            int age; 
                            Date DOB; 
                            ...
                            //
                            //

                            //
                        } 

                        class Employee extends Person {
                            int empId;
                            double salary;
                        }

        Polymorphism 
            - many forms of the same interface depending on the type of object the variable is pointint to 

            

                        class Car {
                            //
                            //
                            //
                            //
                            //
                            public void move(){
                                //
                            }
                        }

                        class BMWCar extends Car{
                            //override
                            public void move(){
                                //child specific behavior of move method
                            }
                        }

                        class MercedesCar extends Car {
                            //override
                            public void move(){
                                //child specific behavior of move method
                            }
                        }


                        Car car = null;



        Class 
        --------
            - a class is a user defined data type 
            - a class is a blueprint for objects 
            - ecapsulate data and logic together 


        Object 
        --------
            - an object is an instance of a class 
            - using 'new' keyword we can create an object of a class 


            class Customer {

                //static variable 
                //final variables 
                //instance variables 

                //constructors 

                //instance methods

                //abstract methods  
            
                //inner class 
            }

            class Product {

            }

            class Employee {

            }


    Constructor 
    -------------
        - special function / method which has the same name as the class 
        - this function is invoked only once, whenever the object of this class is created 
        - used to initialize values for instance members 
        - a class can have multiple constructors, 
            - class should have at least a no-arg constructor 
        

        this keyword 
        --------------
            - this() constructor 
                - it is used to invoke another constructor whithin the same class 
                - call this 'this()' constructor must be the first line 

            - this 
                - used to access the members of the same class 


    ========================
    Explore: 
        - private constructors and its usage 
            - https://www.baeldung.com/java-private-constructors

        - factory methods in java 
            - 

        - method overloading in java 


    ==========================




        public class Employee {

            private int empId;
            private String name;

            public Employee(){      //constructor 

            }

            public Employee(int id, int name){
                this.empId = id;
                this.name  = name;
            }

        }


    a Proper encapsulated class / tightly encapsulated class 
        - when a class has all instance variables defined as private 
            and accessible through the getter/setters only 


    Method Overloading 
    --------------------
        - a class can contain multiple methods with the same name but the parameteres should be diff 
        - compile time Polymorphism / static binding 


    Object class 
    -------------------
        - Object class is by default a super most class for all the classes in java 
        - everyclass is exclusively subclass of object class 

            Object class methods
            ---------------------
                - int hashCode()
                - boolean equals(Object o)
                - String toString() 




                                Object 
                                  |
        ------------------------------------------------------------------------------
        Student                 System          ArrayList           Scanner         ..
        Employee                                LinkedList
        CustomClass...


    Overriding the toString() method 
    ----------------------------------
        - Returns a string representation of the object. In general, the toString method returns a string that "textually represents" this object.
        - It is recommended that all subclasses override this method.
        - whenever we use the ref variable in an expression, by default it calls the toString() on that object 

    Overriding the equals() method 
    -------------------------------------
        - you can override equals() method to provide logic to compare two objects of same type 
        

        **equals() contract 

        Student student = new Student();

        Object object = new Student();        //valid


    **a variable of parent class can reference to an object of clild class 



    Inheritance 
    -----------------
        - allows to create a subclass, inheriting all the non-private members of the super class 
        - using 'extends' keyword we can inherit a class from another class 
        - inheritance creates is-a relationship 

        public class Person {
            //instance variables 
        
            ..

            ..
        }

        public class Employee extends Person {

                //...

                ...

                ..

        }


                    Account 
                        - accNo 
                        - cusotmerID 
                        - type 
                        - interestRate
                        - createAcc() / debit() / credit()
                     |
        ----------------------------------------------------------------------------
        SavingAcc           CurrentAcc              RecurringDepAcc         LoanAcc
                                                                                - loanNo
                                                                                   |
                                                                        ---------------------------
                                                                        PersonalLoanAcc     HomeLoanAcc     



    Has-A relationship / Ojbect Relationships
    ----------------------------
        - objects may have relationship with each other 

        a. Composition 


        b. Aggregation 
            
            - the lifecycle of object is tied up 

                class Engine {

                }

                class Car {

                    Engine engine;
                }


        c. Association 

                public class Book {                         public class Author {
                    int bookId;                                     int authorId;
                    String title;                                   String name;
                    Author author;

                }                                           }


    class {
        instance variables
        constructor 
        instance methods 
        ...
        ..
    }


    Interface 
    --------------------
        - similar to a class, but it describes only abstract methods 
        - interface contains only 'public abstract' methods and 'public static final' variables 
        - interfaces are used to define set of requirements that a class has to implement 
        - a class must implement an interface and override the abstract methods
        **- an interface can extend from several interfaces

        interface <<InterfaceName>>{

                public static final variables;

                public abstract methods;

        }

        interface Taxable {
            public abstract void calcTax(double intRate);
        }


        class ClothingProduct implements Taxable, AnotherInterface{

            //override the abstract methods of the interface 
            public void calcTax(double intRate){
                //define the logic 
            }
        }

        Taxable product = new ClothingProduct();


        **A variable of type interface can reference to an object of its implementation class 


    Abstract classes 
    -------------------
        - abstract classes are used to act just a superclass, representing data & code to be inherited to the subclasses 
        - using 'abstract' keyword we can declare abstract class
        - we cannot instantiate abstract classes 
            - we cannot create object of abstract class 

        - if a class has 'abstract' methods, then it must be marked as abstract
            - the abstract methods of a class must be overridden by its immediate subclass 


        

        public abstract class Car {

            //instance variables 
            //static variables 

            //constructor 

            //instance methods 

            public abstract void move();

        }

        public class BMWCar extends Car {

            public BMWCar(){
                
            }

            //override the superclass methods 
            public void move(){
                sysout("BMW Car moves fast")
            }
        }


        public class MercedesCar extends Car {

            //override the superclass methods 
            public void move(){
                sysout("MercedesCar moves fast and smooth");
            }
        }

        Car car = new BMWCar();
        car.move();

        car = new MercedesCar();
        car.move();

    Method Overloading 
    ---------------------
        - writing multiple methods with same name but diff parameters inside the same class 


    Method Overriding 
    --------------------
        - redefining a super class method in the subclass using the same method signature 
        - it is used to define child specific behavior of the superclass method 
        - in method overriding, the name, parameters and return type must be same


        -Rules for method overriding 
        --------------------------------
            - 1. only the inherited methods (non-private) can be overridden 
                    Note: private and static method cannot be overridden 

                    public class A {
                       public void method(){

                       }
                    }

                    public class B extends A{

                    }

            2. the overridden method can not have restrictive access in the subclass 

                    public class A {
                       protected void method(){

                       }
                    }

                    public class B extends A{
                        public void method(){

                       }
                    }

            3. the overridden method must have the exact* method signature in the subclass 
                    Note: the return type in the overridden method can be a subtype


    Abstract Method 
    ----------------------
        - a method without definition 
        - a method declared using 'abstract' keyword 


     ..


   
   
        interface EmploeyeRepository {

            public abstract void addEmployee(Employee employee);
            
            public abstract Employee getEmployee(int empId);
            
            public abstract List<Employee> getAllEmployees();
            
            public abstract void deleteEmployee(int empId);

        }

        public class EmploeyeRepositoryImpl implements EmploeyeRepository{

            //must override all the methods of the interface
            public  void addEmployee(Employee employee){

            }

            public  List<Employee> getAllEmployees()
        }

















    Arrays are fixed length / size group of elements 


    Collection Framework 
    --------------------------
        - java.util provides various data structures called as collections
        - Collection classes offer various DS to allow creating dynamic group of objects 
        - collections are set of dynamic and reusable datastructures which are used to create group of objects 

                    Iterable<E> interface 
                        |
                        |
                    Collection<E> interface
                         |
                         |-> boolean add(E e)
                         |-> boolean	addAll(Collection<? extends E> c)
                         |-> void	clear()
                         |-> boolean	contains(Object o)
                         |-> boolean	remove(Object o)
                         |
                         |
          ------------------------------------------------------------------------------  
          List<E> Interface                 Set<E> Interface               Queue<E> Interface 
             |                                  |                               |
             |                                  |                               |-->LinkedList<E>
          ArrayList                         HashSet                             |-->PriorityQueue<E>
                                                                                |
          LinkedList                        LinkedHashSet               ----------------------------------------
          Vector                            TreeSet                     Deque<E> Interface         BlockingQueue<E> Interface
          Stack                                                             |                                  |
                                                                            |                           ArrayBlockingQueue<E> 
                                                                            |
                                                                        --------------------------------------
                                                                       ArrayDeque<E>       BlockingDeque<E> interface 



             




   Collection<T> interface
    - this is the supermost interface in the collection hierarchy that describes few common methods 
    - ie.                |-> boolean add(E e)
                         |-> boolean	addAll(Collection<? extends E> c)
                         |-> void	clear()
                         |-> boolean	contains(Object o)
                         |-> boolean	remove(Object o)

    List<E> Interface 
    ------------------
        - models an indexed collection of elements, it allows duplicate elements 
        - List Implementation classes are ...
            1. ArrayList<E> 
                - internally uses "resizable array" as a datastructure 
                - the initial capacity of arraylist is 10
                - not synchronized

            2. LinkedList<E> 
                - internally uses "double linked list" as a datastructure 
                - the initial capacity is 0
                - good for lists that require freqent insertions, deletions

            3. Vector<E> 
              - internally uses resizable array as a datastructure 
              - the initial capacity of arraylist is 10
              - vector is synchronized, so it is thread safe

            4. Stack<E>
              - internally uses resizable array as a datastructure 
              - offers LIFO approach   


    Set<E> Interface 
    ---------------------
        - Set interface models a collection of object that doesn't allow duplicate elements 
        - whenever we add a new element, it first compares the element with all objects (using their equals() and hashCode() ) in the set, 
            if it doesn't exisit then only the new element will be added 
        - Note: if you create a set of custom objects, make sure you implement the hashCode() and equals() methods correctly 
        - Set Implementation classes -- 

            1. HashSet<E> 
                - doesn't guarantee order of insertion 
                - internally uses 'HashTable' structure 

            2. LinkedHashSet<E> 
                - stores elements as per the insertion order 
                - uses 'HashTable+double linked list' data strcuture 
            
            3. TreeSet<E> 
                - maintains the sorted order of elements 
                - uses 'balanced tree' data structure 


     Queue<E> Interface 
     ---------------------
        - FIFO approach 
        - it models a collection in the form of a queue that has FIFO approach 

                |       |       |       |       |       |       |



    hashCode()
        - its an integer number represening the object; 
        - The default implementation of the hashCode method is provided by the Object class, 
                which returns a unique integer value for each object based on its memory address.


    equals() and hashCode() contract 
    -----------------------------------
        - if two objects are equal to each other based on equals() method, 
                then the hash code must be the same
        - unequal objects may have the same hashCode


    Natural Ordering 
    ---------------------
        - natural ordering is the default ordering of elements while sorting in array / collection 
        - if you create a collection of custom objects, and want them sorted, then you must define 
            the natural ordering of the elements 

        - using below two interfaces we can define natural ordering of custom objects 
        - 1.  interface Comparable

                    interface Comparable<E> {
                        int compareTo(E obj);
                    }

                    class Student implemets Comparable<Student> {
                        //
                        //
                        int marks;

                        public int compareTo(Student otherStudent){
                            
                            //return a compare value
                            if(this.marks > otherStudent.marks)
                                return 1;
                            else if (this.marks == otherStudent.marks)
                                return 0;
                            else 
                                return -1;
                        }
                    }

        - 2.  interface Comparator
                - this is used to create external comparators 


                public class StudentNameComparator implements Comparator<Student>{

                    public int compare(Student s1, Student s2){
                            //logic to return a compare value
                    }
                }
    

    **Compare Value 
        - its an integer number 

            
            e1.compareTo(e2)
            if first object is > second object         : return 1 or positive number 
            if first object is < second object         : return -1 or negative number 
            if both are equal                          : return 0


   
    Create a list 
    ------------------

        - non-generic list 

            ArrayList list = new ArrayList();
            List list = new ArrayList();
            List list =  new LinkedList();

        - generic list 

            ArrayList<Integer> list = new ArrayList<>();
            List<String> listNames = new ArrayList<>();

            List<Integer> list = new LinkedList<>();



    Create a Set

            Set set = new HashSet();
            Set<Integer> set = new HashSet();










     List list = new ArrayLists()
     ArrayList list = new ArrayList();


    ArrayList
    ------------
        - ArrayList is one of the implementation class of List Interface 
        - used to list of objects 
        - the initial capacity of arraylist is 10

        ArrayList list = new ArrayList();
        list.add(10);
        list.add(30);
        list.add(40);
        list.add(60);





    Enumerator, Iterator, ListIterator  
    -------------------------------------
        Iterator 
            - common object for iterating over any type of collection i.e list, set, queue etc. 
            - allows to iterate collection only in forward direction 

        ListIterator 
            - specific to Lists, used to iterator over lists 
            - has next() and previous() methods, which allow to iterate in both directions 

        
        Enumeration 
            - this is also used to iterate over collection 
            - Collections.enumeration(collection) creates the enumerator 



        Queue<E> Interface methods 
        -----------------------------

            insert the element                  add(E e)                    offer(E e)

            remove the element                  remove()                    poll()

            inspect / fetch the element         element()                   peek()


        Deque<E> Interface 
            - represents a double headed queue 

            insert the element                  add(E e)                    offer(E e)
                                                addFirst(E e)               offerFirst(E e)

            remove the element                  remove()                    poll()
                                                removeFirst()               pollFirst()

            inspect / fetch the element         element()                   peek()
                                                peekFirst()                 peekLast()


       BlockingQueue<E> Interface methods 
        -----------------------------

            insert the element                  add(E e)                    offer(E e)          put(E e)

            remove the element                  remove()                    poll()              take()

            inspect / fetch the element         element()                   peek()


        
        Map<K, V> Interface 
        --------------------
            - models a collection of elements of objects in the form of key-value pairs 
            - the key can be of any type, the value also can be of any type 
            - cannot have duplicate key, all the keys should be unique 

            - Map implementation classes are... 

                1. HashTable<K,V>
                        - doesn't allow null key 
                        - synchronized

                2. HashMap<K,V>
                        - allows one null key 
                        - not synchronized

                3. LinkedHashMap<K,V> 
                        - maintains order of insertion by keys 
                
                4. TreeMap<K,V>
                        - maintains sorted order of keys based on their natural ordering 


            Map<Integer, String> map = new HashMap<>()
            Map<Integer, String> map = new LinkedHashMap<>()
            Map<Integer, String> map = new TreeMap<>()


        Iterate over a Map 
        -----------------------

                Collection<T> values()

                Set<K> keySet();

                entrySet()


    Exception Handling 
    ----------------------
        - exception is an abnormal event that might occur during the program execution 


            - Compile time errors 
                    - invalid code syntax 
                    - invalid variables 
                    - incomplete types 
                    - misspelling 

            - Expcetion
                - abnormal event that occurs at run time 
                    i.e. input is invalid, code logic is incorrect, file/db connection fails, dependencies fails etc. 


            - Java allows to handle such exceptions and do the needful as corrective steps 

            - to handle the exception 
                1. find the problem - hit the exception 
                2. inform that the problem has occured - throw the exception
                3. receive the information about the problem - catch the exception 
                4. take corrective actions - handle the exception  

        Exception class hierarchy
        ------------------------------

                    Throwable 
                       |
        ---------------------------------------------------------------
        Exception                                                   Error 
            |                                                        |
            |->represents the issues occured at run-time             |-> represents internal system errors (Memory errors, virtual machine error)
            |                                                        |-> LinkageError
            |
    ---------------------------------------------------------------------------
    RuntimeException                IOExeption          SQLException        EmployeeNotFoundException
      |
    ArithmaticException
    InputMismatchException
    ArrayIndexOutofBoundExpception 
    NullPointerException 
    IllegalStateException 


    ** Default exception handler 
        - If run-time system searches all the methods on call stack and couldn’t have find the appropriate handler 
            then run-time system handover the Exception Object to default exception handler, which is part of run-time system.
            This default handler prints exception class name, exception description and stacktrace and terminates program abnormally.


    Unchecked Expcetions 
        - not necessarily handled by try-catch block 
        - if there is no handler found, these exception are handled by the "default exception handler"
        - all the "RunTimeExceptions" are unchecked 

    Checked Expceptions 
        - must be handled by writing try-catch block or they can be declared to be thrown


        Below concepts are used to handle the exception 
        --------------------------------------------------
            - try-catch block
            - 'throws' keyword 
            - 'throw' keyword 
            - 'finally' keyword 
            - try with resources block (introduced in java7)
                - you can use try with resource block only for 'Closable' resources 
            - creating custom exception classes 



                try {
                    //make a connection to the db 

                    //perform some db related oprations here..
                    //the code to be monitored 

                   

                }catch(XYZException ex){

                }catch(PQRException ex){

                }finally{
                     //once the operations are done, close the connection
                     //release the resources 
                }



                try(open the connection to db / file / etc){

                }catch(Exception ex){

                }





    Multi Threading 
    ----------------
        - every java program runs inside a thread, i.e. Main Thread 

        There are three ways to create a thread 

        1. using the Thread class 
            a.  create a custom class that extends the Thread class 

                    class MyThread extends Thread {

                    }

            b. override the 'run()' method to define the task you want to execute in the thread 

                    class MyThread extends Thread {

                        public void run(){
                            //code to be executed inside a thread.
                        }
                    }     
            c. start the thread 
                 calling the 'start()' method on the thread object       

        2. using the Runnable interface 

            a. create a class that implements Runnable interface & override the 'run()' method to define the task you want to execute in the thread 
                - this class just represents the code that is supposed to be executed inside a thread 

                    class MyTask implements Runnable {
                        public void run(){
                            //code to be executed inside a thread.
                        }
                    }

            b. Create a Thread Object, initialize the runnable task and start the tread 
                    MyTask task1 = new MyTask();
                    Thread t1 = new Thread(task1);





        How to pause a thrad 
            - Thread.sleep() method 

        How to interrupt a thread 
            - Thread.interupt(); 

        how to make a thread wait for another thread 
            - .join() method 


        Thread synchronization 
        --------------------------
            - implement synchronization
                = 1. using the ReentrantLock object (old technique)
                = 2. making the methods synchronized


        Thread DeadLock 
        ----------

            class A {

                synchronized void methodA() {
                    B.methoB()
                }
            }


            class B {
               synchronized void methodB() {
                    A.methodA();
                } 
            }

        3. Creating threads and executing multiple tasks using "Concurrent API" 

                   1. java.util.concurrent package 
                        **- provides the utility classes commonly useful in concurrent programming 
                            i.e. Executors 

                   2. java.util.concurrent.locks package 
                        - provides Lock and Condition implementations 

                   3. java.util.concurrent.atomic package  
                        - provides some data types i.e. AtomicInteger 



            java.util.concurrent
            ---------------------------
                    - provides utility classes that are used to create "thread pools" 
                    - instead of creating a new thread whenever a task arrives / every time, 
                            you can use a thread pool which keeps a number of reusable threads ready for executing the task 
                    - the "Executors" provides various methods to create a pool of threads 

                    1. Executor 

                    2. ExecutorService 

                    3. ScheduledExecutorService 



                methods to create thread pools 
                -------------------------------
                    1. newSingleThreadExecutor()
                    2. newFixedThreadPool(0)



            <T> Future<T>	submit(Callable<T> task)
                - Submits a value-returning task for execution and returns a Future representing the pending results of the task


        Future interface: 
        -------------------
            - it is an interface, 
            - A Future represents the result of an asynchronous computation 

                    interface Future<V>{
                        V	get()
                            // Waits if necessary for the computation to complete, and then retrieves its result.
                        V	get(long timeout, TimeUnit unit)
                            //Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available.
                    }

        Callable interface 
        ------------------
            - public interface Callable<V>
                    - A task that returns a result and may throw an exception
                    - override the V call() method 

        //class B represents a Callable task - a task that can be executed inside a thread, and it may return a value or throw exception
        class B implements Callable<V> {
                //override 
                public V call(){
                    //perfom some async task 
                    //calculate some values
                    return a value V;
                }
        }

        B taskB = new B();



        //class A represents a runnable task - a task that can be executed inside a thread 
        class A implements Runnable {
                //override 
                public void run(){

                }
        }

        ExecutorService poolService = Executors.newSingleThreadExecutor();
        poolService.execute(Runnable target)
        poolService.submit(Callable target)

        Future<V> futValue =  poolService.submit(taskB);          //internaly this method uses a thread from the pool, and executes the taskB
        V value  = futValue.get(5, TimeUnit.SECONDS);
        V value  = futValue.get();






                        Executor<T> interface 
                            |
                            |-> void execute(Runnable target)
                            |
                        ExecutorService<T> interface 
                            |
                            |-> void execute(Runnable target)
                            |-> Future<V> submit(Callable target)
                            |-> shutdown()
                            |-> isDone()
                            |
                        SchelduledExecutorService<T> interface 
                            |
                            |-> ScheduledFuture<?>	schedule(Runnable command, long delay, TimeUnit unit)
                            |-> ScheduledFuture<?>	scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)
                            |-> ScheduledFuture<V>	schedule(Callable<V> callable, long delay, TimeUnit unit)


        JDBC 
        ------------
            - java database connectivity 
            - jdbc is just a specification or standard that every db vendor has to implement 
            - every DB Vendor generally provides "driver" to communicate with the database 
            - to use the MySQL Database you have to first download the 'mysql-sql-driver'


            - Driver class 
                - responsible to communiate with the respective database 


            db                          Driver class name                   url 
            mysql                       com.mysql.cj.jdbc.Driver            jdbc:mysql://localhost:3306/mydb
            oracle                          
            ms sql server 
            h2 
            ..
            ..


            DriverManager class 
                - used to create the "Connection" with the database 

            Connection object 
                - Connection object represents the connection to the db and used to send sql commands to the databse 

            Statement Object 
                - using the Connection object, we can create 'Statement' objects 
                - using the 'statement' object we can submit the sql commands / sql queries to the db 

                    1. Statement 
                            connection.createStatement()
                            - using statement object we can execute any sql statement, but it requires lot of concatenation for dynamic values 
                            - we cannot store binary values using object 
                            - the sql query is compiled every time we execute the statement

                    2. PreparedStatement 
                            connection.prepareStatement()
                            - it represents a pre-compiled query, and can also have paramterised queries 
                            - 

                    3. Callable Statement 
                            connection.callStatement();



        Steps to connect / communicate with the database 

            1. load the db drivers 

                        Class.forName("com.mysql.cj.jdbc.Driver");

            2. create Connection with the db 

                      Connection connection =  DriverManager.getConnection("urlOfTheDb","username","password");

            3. create the Statement object 

                          Statement statement =  connection.createStatement();

            4. execute the sql commands / submit the sql queries to the db 

                            int executeUpdate(String query)
                                - submits the sql statement to the db, and returns an int value that represents the number of rows affected 
                                - used to INSERT, UPDATE and DELETE 

                            ResultSet executeQuery(String sql)
                                - submits the sql statement to the db, and returns an object of "ResultSet"
                                - ResultSet object represents table of data fetched from the db 
                                    - it has a cursor, which by default points to the row before first row 
                                    - the .next() advances the cursor to the next row, returns true if the next row is available 
                                    - using the getXXXX() methods we can read the data from each row 

                                    rs.getInt(1)            rs.getInt("empId")

                            statement.execute();

            5. close the connection 

                    connection.close();



        
         --->   '101','Vishal','Pune','2000'
            '102','Vaibhav','Pune','3000'
            '103','Om','Mumbai','1200'
            '104','Rohit','Hyderabad','8000'
            '105','Mohit','BLR','3500'


    Java 8 Features 
    -------------------
        - Functional interfaces 
        - Lambda expressions 
        - pre-defined / inbulit functional interfaces 
            - Predicate 
            - Supplier 
            - Consumer 
            - Function 
        - Stream API 




    Functional interfaces 
    ------------------------
        - the interface which has only 1 abstract method is called Fuctional Interface 

            @FunctionalInterface
            interface Taxable {
                public double calcTax(double intRate);
            }

            interface Runnable{
                public void run();
            }

            interface Callable<V>{
                public V call();
            }

            interface Comparable<T>{
                public int compareTo(T t)
            }

            interface Comparator<T>{
                public int compare(T t1, T t2);
            }


    Ways to implement the Functional interfaces 
    ---------------------------------------------
        A. by creating a class that implements the interface 

                class Product implements Taxable{
                    //override the abstract method of the taxable interface 

                    public double calcTax(double intRate){
                        //logic 
                        //code
                    }
                }

                class EmplSalComparator implements Comparator<Employee>{
                    public int compare(Employee e1, Employee e2){
                        //logic 
                    }
                }

                class MyTask implements Runnable {
                    public void run(){
                        //code 
                    }
                }
        B. by creating an annonymous object / instance 

                Runnable task1 = new Runnable(){
                        public void run(){
                            //code 
                        }
                };


        C. using Lambda Expression 

            Runnable task1 = () -> //code 
                        
     Lambda expressions  
     -------------------
            - offers a simplified way to implement a functional interface 


     - pre-defined / inbulit functional interfaces 

            - Predicate 
                - a functional interface that represents a predicate (boolean-valued function) of one argument.

                Interface Predicate<T>{
                    boolean	test(T t);
                }

            - Supplier 

                - Interface Supplier<T>{
                    T get() 
                }

            - Consumer

                    interface Consumer<T>{
                        void	accept(T t)
                    } 

            - Function 
                Interface Function<T,R>{
                    R	apply(T t)
                }

    Stream API 
    ------------------
        - a stream represents a sequence of elements and supports sequential as well as parallel aggregate operations 
        - process the collections, array and any I/O channel  

        - Every collection class has the stream() method that returns a 'Stream' of elements 

            List<String> list = new ArrayList();

            list.stream();
            Stream.of(list);

    Stream Operations 
    ---------------------
        - intermediate operations 
            - filter(predicate) 
                - returns a new stream that consist elements matching a given condition 

            - map(function) 
                - returns a new stream consisting elements which are the result of the given function
                - mapToInt()
                - mapToLong() 
                - mapToDouble()

            - sorted() 
            - limit() 
            - distinct() 

           


        - terminal operations 
            - collect() 
            - reduce() 
            - forEach() 
            - allMatch()
            - anyMatch()
            - nonMatch()
            - count() 
            - min(comparator) 
            - max(comparator)



    JDBC challenges 
    -----------
        - heavily dependent on sql queries, you have to write complex queries 
        - if you make any changes to the model / bo classes, then you have to make lot of changes in the code as well as in the db tables 
        - using jdbc as a low level api, there may be lot of code duplications 


    ORM - object relational mapping frameworks 
    -------------------------------------------
        - orm tools allow s to map the java objects with the relational tables 
        - Object-Relational Mapping or ORM is a technique for converting data between Java objects and relational databases

        - Hibernate 
        - iBatis 
        - TopLink 


    JPA - Java Persistence API 
    ----------------------------
        - it is just a specification / standard 
        - every ORM tool must implement this standard 
        - JPA is vendor independent "specification" for mapping java objects with relational tables 


     JPA Vendors / JPA Providers 
     -------------------------------
        - Hibernate JPA 
        - MyBatis 
        - EclipseLink
        - OpenJPA
        - ..


    Entity
    -----------
        - entities in jpa are POJO classes 
        - an entity is an object which is persisted / managed by the JPA providers 

        @Entity
        public class Employee{

            @Id
            private int empId;


            public Employee(){

            }
        } 


    EntityManager 
    ----------------
        - EntityManager is an object which is used to manage the entities 
        - EntityManager is responsible to persists the entities in to the database 


    PersistenceContext 
    ----------------------
        - it is a configuration for one or more persistence units 
        - A persistence unit defines configuration for mapping the java classes with the database 
        - the configuration is described in a xml file called "persistence.xml" 

        - persistence.xml 
        ----------------------
            <persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="2.1" xsi:schemalocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd">
                <persistence-unit name="my-persistence-unit">
                    <classes>
                        //define which java classes you wish to be mapped with the database 
                    </classes>
                    <provider>
                        //provier class name
                    </provider>
                    <properties>
                        //in which db you want to persist the data 
                        //db url 
                        //db username 
                        //db password
                    </properties>
                </persistence-unit>
            </persistence>


    JPQL 
    -------
        - is object oriented way to commnicate with the database 


        sql command 
            "SELECT * FROM employee WHERE sal > 3000"

        jpql command 
            SELECT e.empId, e.name, e.salary FROM Employee e; 



        Project 
        ---------------
            - Entity classes 
                
                @Entity
                public class Employee{

                    @Id
                    private int empId;


                    public Employee(){

                    }
                } 

            - create an object of EntityManager 

              EntityManager entityManager =  EntityManagerFactory.createEntityManager("my-persistence-unit")

                Employee emp = new Employee(-,-,-,-,);
                entityManager.save(emp);

    JPA 


    JPA Provider 


    Spring Data JPA 
        - is a module/sub-project in spring framework that offers 'Respository' pattern wrapping up 
            the JPA provider 

    Reflection API 
    -----------------



    Design Patterns 

        - Singleton 
        - factory 
        - builder 


Types of applications 
-------------------------

    - web applications **
    - REST API applications **
    - mobile applications 
    - event driven applications 
    - batch applications 
    - console applications 
    - game applications 
    - service worker applications 
    - Serverless applications 
    - cloud native applications
    - microservice based applications  **


    overview and features of Java version 9 to 17 
    -----------------------------------------------



    Spring Framework 
    -----------------------
        - helps to build software applications 
        - The Spring Framework provides a comprehensive programming and configuration model for modern Java-based enterprise applications - on any kind of deployment platform.
        - Spring makes it easy to create Java enterprise applications

            - build 
            - deploy 
            - manage the dependencies
            - monitor 
            - debug / troubleshooting  
            - implement security 
            - better project structure 

            Features of Spring Framework 
                Core technologies: dependency injection, events, resources, i18n, validation, data binding, type conversion, SpEL, AOP.
                Testing: mock objects, TestContext framework, Spring MVC Test, WebTestClient.
                Data Access: transactions, DAO support, JDBC, ORM, Marshalling XML.
                Spring MVC and Spring WebFlux web frameworks.
                Integration: remoting, JMS, JCA, JMX, email, tasks, scheduling, cache and observability.

   Modules / Projects in Spring Framework

       1. Spring Core 

            - IOC - Inversion of control 
                - tranferring the control / delegating the responsibility of creating the objects to a container or framework 
                - in Spring, there are container classes who are responsible to create / manage the objects 


            - Dependency Injection 
                - a java application is made up of several objects, one object may be dependent on another object 
                - 'injecting' means connecting one object to another object 


            - Containers 
                - responsible to manage the objects, i.e. instanstiating the objects, initializaion, destroy the objects 
                - containers manage the life cycle of objects 

                - in spring we have 3 types of containers 

                    1. BeanFactory 
                            - this is a super interface that models various type of BeanFactory containers 
                            - XmlBeanFactory  

                    2. ApplicationContext
                            - a super interface that models several ApplicationContext containers 
                            - ClassPathXmlApplicationContext
                            - FileSystemXmlApplicationContext
                    
                    3. WebApplicationContext
                        - XmlWebApplicationContext
                        - AnnotationConfigWebApplicationContext

            - Spring Bean 
                - an object that is managed by the container 


            - Bean definitions / Spring Bean Definitions 
                - a configuration for the spring container using which container creates the objects 

                    a. using xml  

                            application-context.xml 
                            --------------------------
                            <beans>
                                <bean id="employeeDao" class="com.demo.dao.EmployeeDao"> 
                                
                                </bean>

                                <bean id="employeeDao" class="com.demo.dao.EmployeeDao" /> 
                            
                            </beans>

                    b. using java 
                    ---------------
                            @Configuration
                            public class ApplicationConfig {

                                @Bean
                                public Employee createEmployee(){
                                    //java code to create object of type employee 

                                    return employee;
                                }

                                @Bean	
                                public AccountRepository jdbcAccountRepository(){
                                    
                                    JdbcAccountRepositoryImpl accountRepositoryImpl= new JdbcAccountRepositoryImpl(dataSource);		
                                    return accountRepositoryImpl;
                                }
	
                            }

                    c. using java annotations & use the component scan to automatically scan the packages for the classes 
                        which are marks with below annotations : 
                            @Component 
                            @Service 
                            @Repository 
                            @Controller 


                - Constructor injection 

                - Setter injection 

                - Autowiring 
                    - Autowiring is a technique used in Spring to enable automatic dependency injection. By using it Spring container can autowire relationships between collaborating beans. It is known as Spring Autowiring.

                - injecting collections (arrays, lists, sets, maps)

                - Scopes 
                    - scopes define how many instances of the beans should be created, by default scope is 'singleton' 

                    singleton
                    prototype
                    request
                    session
                    application
                    websocket
                    thread 


                - bean life cycle methods 
                -----------------------------
                1. using xml 
                        <bean id="" class="" init-method="" destroy-method="" >
                            <property name="" value="" />
                            ..
                            ..
                        </bean> 
                        
                        - 1. constructor 
                        - 2. setter method if property injection is configured
                        - 3. post initilization 

                2. implementing InitialzingBean interface and DisposableBean interface 


                3. using @PostContruct() @PreDestroy()



       2. Spring AOP 

       2. Spring Web  
            - Spring MVC 
            - Spring REST 

       3. Spring Data 
            - Spring Data JPA 
            - Spring Data MongoDB 
            - 

       4. Spring Cloud 
            - Spring Cloud config 
            - Spring Cloud Gateway 
            - Spring Cloud Eureka 
            - Spring Cloud Circuit Breaker 

       5. Spring Security 

       6. Spring Boot 
            - spring boot provides auto configuration feature that helps in configuration of beans 
            - based on presense and absense of some dependencies in classpath / based on presence  and absense of some properties 
                in application.properties file it automatically creates beans as per the requirement 

            - provides starter dependencies
                - it aggregates commonly used dependencies 

                    - spring-boot-starter-data-jpa 
                    - spring-boot-starter-web 
                    - ..
                    ..



    DAO Layer 
    -------------
        - low level jdbc 
        - spring jdbc template 
        - ORM Tools i.e. hibernate, iBatis, toplink 
        - JPA Providers i.e. Hibernate JPA, MyBatis, EclipseLink, OpenJPA
        - Spring Data JPA 

    Spring Data JPA 
    ------------------
        - part of Spring Data project 
        - Spring Data JPA is a wrapper around JPA & the JPA providers 
        - it offers 'Repository' pattern 
        - using Spring Data JPA we can seamlessly implement the data access layer 
        - it supports 'QueryDSL' 



                interface Repository<T, ID>
                    |
                    |->it is a super interface that represents the repo pattern 
                    |-> Central repository marker interface. Captures the domain type to manage as well as the domain type's id type. General purpose is to hold type information as well as being able to discover interfaces that extend this one during classpath scanning for easy Spring bean creation.
                    |
                interface CrudRepository<T, ID>    
                    |
                    |-> describes common methods to perform CRUD operations
                    |-> <S extends T> S save(S entity) ->Saves a given entity
                    |-> Optional<T> findById(ID id) -> Retrieves an entity by its id.
                    |-> Iterable<T> findAll() -> Returns all instances of the type.
                    |-> void deleteById(ID id)  ->Deletes the entity with the given id.
                    |
                    |
                Interface PagingAndSortingRepository<T,ID>
                    |
                    |-> Iterable<T> findAll(Sort sort) -> Returns all entities sorted by the given options.
                    |-> Page<T> findAll(Pageable pageable) ->Returns a Page of entities meeting the paging restriction provided in the Pageable object.
                    |
                interface JpaRepository<T,ID>




    **Marker Interface 
    ======================
        - Explore this concept 


    **Optional object in java 
    ===========================
        - Explore this concept 


    **Explore - how spring data jpa works internally 
    ==========================


        QueryDSL 
        ------------



        com.demo 
            SpringDataJPAApplication.java 
        com.demo.entities 
        com.demo.services 
        com.demo.repositories 



    Entity Relationships 
    ---------------------------
        - in java, the relationship between two entities can be described using 'association' 
        - in relational dbs, the relation between tables are represented using 'referential integrity' 

            @Entity 
            public class Order {

                private ShippingAddress shippingAddress;
            }

            @Entity 
            public class ShipingAddress{

            }

        *Direction 
            - Bidirectional 
            - unidirectional 
        *Cardinality 
            - ?

        - @one-to-one 

                Order -----------------------1 ShippingAddress

                Husband 1---------------------1 Wife 

                

        - @one-to-many 

                Student *---------------------1 Class 

                Customer 1-------------------* Order

        - @many-to-one 
        
                Class 1 -------------------* Student 

        - @many-to-many 

                Product *--------------*   Customer 
                p1                          c1
                p2                          C2
                p3                          C3






            1. how to describe the relationship in java 
                   - using appropriate annottions 
                        - @OneToOne       
                        - @OneToMany 
                        - @ManyToOne 
                        - @ManyToMany

            2. how the relationships are represented in the relational db
                    - using join-column - (ref column /  foreign key column )
                    - using join-table  - (creates a new table to represent the relationships )

            3. how to perform db operations when entities have relationships 
                    - configure the cascade type and fetch type appropriately 




            @OneToOne               join-column         - eager fetch 
            @ManyToOne              join-column         - eager fetch 

            @OneToMany              join-table          - lazy 
            @ManyToMany             join-table          - lazy



            Cascading 
            ----------------
                - when we parent entity (Order) then it's child entities should also be saved first (Address)

                - when we delete the parent entity (car) then it's child may be required to be deleted (engine) 

                - Cascading types 

                    CascadeType.PERSIST     
                        - save() operations cascase to the related entities 
                        - if you save parent entity, it's child will be automatically saved 

                    CascadeType.MERGE 
                        - the related entities are merged when owning entity is merged 

                    CascadeType.REFRESH 
                        - refresh() operation

                    CascadeType.REMOVE 
                        - if the parent entity is removed, it's child will be also removed 

                    CascadeType.DETACH 
                        - detaches all related entities 

                    CascadeType.ALL  


            Fetch Policy 
            --------------

            Eagar Fetch 
                - by default if the relationship is OneToOne / OneToMany 
                    - whenever we query an entity, all its related entities are also fetched 

            Lazy Fetch 
                - if the entities have relationships 
                    - calling the getter method will trigger the fetch operation on the related entities 





            Unidirectional OneToOne 
            -------------------------
                    public class Order{                           public class Address {
                        private int id;                             private int addId;
                        private String trackingNo;                  private String street, city, state; 
                        private ..

                        @OneToOne 
                        private Address shippingAddress;


                    }                                              }

            orders_Table                                                     address_table 
            -------------------------------                                  -----------------
            id  tn  tp  qty     fk-add_id                                   add-id   street   city  state 



            1. create the entity classes with relationships 
            2. observe the table structure in db 



            Bidirectional OneToOne 
            -------------------------
                    public class Order{                           public class Address {
                        private int id;                             private int addId;
                        private String trackingNo;                  private String street, city, state; 
                        private ..

                        @OneToOne                                   @OneToOne
                        private Address shippingAddress;            private Order order;


                    }                                              }

            orders_Table                                                     address_table 
            -------------------------------                                  -----------------
            id  tn  tp  qty     fk-add_id                                   add-id   street   city  state   FK_order_id 


        **Though you have bidirectional relationship, having the foregin key column in both the tables are required 
            - we can define an 'owner' of the relationship using 'mapped by' attribute in @OneToOne annotation 




            **Explore Project Lombok 
            ============================
                - https://www.baeldung.com/intro-to-project-lombok


        1                                                   *
        public class Order {                                public class OrderItem {        

            private long id;                                    private long orderItemId;
            private String trackingNo;                          private int quantity;

                                                                @OneToOne
                                                                private Product product;
            @OneToOne 
            private Address shippingAddress;
          
            @OneToMany
            List<OrderItem> orderItems;

        }                                                   }




        public class Product {
            int id 
            String sku 
            double price 
            ..
            ..
            ..
        }


        Fetch / Query operations with JPA 
    -     ---------------------------------
            - use Spring data jpa query methods 
            - use @Query annotation and define the jpql query statements 
            - use @NamedQuery annotation and define jpql query statemetns 
            - use @Query annotation and define the native sql query statement 
            - use the Criteria API in JPA to generte queries dynamically 


        QueryDSL
        ------------
            - Querydsl is a framework which enables the construction of type-safe SQL-like queries for multiple backends including JPA, MongoDB and SQL in Java
            - execute dynamic queries 
            - to use QueryDSL we need add two dependencies in pom.xml file 
                    - querydsl-jpa 
                    - querydsl-apt 

            -*querydsl-apt (Annotation Processing Tool)
                - it automatically generates Q-Type class for each Entity 
                    - using these qtypes we can generate dynamic quries 

                    @Autowired 
                    private EntityManager entityManager; 

                    QProduct qProduct = QProduct.product;
                    JPAQuery<Product> query = new JPAQuery(entityManager)

                    query.from(qProduct).where(qProduct.price.between())


        Transactions
        ----------------
            TransactionManager
            
            
        Spring AOP 
        --------------------
            - aspect oriented programming 
            - allows to perform "cross cutting" operations 
            
        
        Web Applications / Server side application / backend application 

        Web application 
            - returns a "view" along with "data"
        
        Web Services 
        ---------------
            - returns only "data"

           a. SOAP Service - [Simple Object Access Protocol] 
                - exchange data in the form of XML 

           b. REST Service / REST API Application [Representational State Transfer.]
                - exchange data in various formats like JSON
                - REST supports XML, JSON, plain text, HTML.


        Spring Web 
            Spring MVC 

            Spring REST 



        @Controller     
            - describes the class as a controller class which can have several 'handler methods'
            - is used to create Web Controllers that returns 'views' 
        
        
        @RESTController
            - describes the class as a controller class which can have several 'handler methods'
            - is used to create REST Controllers that returns 'data'



        'handler methods'
            - methods mapped with specific http request 
            - @Getmapping / @PostMapping / @PutMapping / @PatchMapping / @DeleteMapping 


        Template Engines / View Engines 
            - JSP 
            - Thymeleaf
            - Jade 
            - ...
            - .. 

        REST API - Important Terms 
        ---------------------------
            - Resource 
                - resource can be anything for which you explose an end point for 
                - ideally all the entities/DTOs can be the resourses you develop the api endpoints for 

                - E-Commerce Application 
                ---------------------------
                    - Product 
                    - Order 
                    - Cart
                    - Customer 
                    - ProductCategory 

                    http://localhost:8080/api/products 


            - Sub-Resource 
                - the associated entities/DTOs 
                - i.e. Product --> ProductCategories

            - URI - Uniform resource identifier 
                - the Resource can be identified by URI 

                    http://localhost:8080/api/employees 

            - HTTP Methods 
                - GET
                - POST 
                - PUT 
                - PATCH 
                - DELETE 

            - HTTP Status Codes 
                    100-199       - informational 

                    200-299       - Success 

                        200     - Successful REsponse 
                        201     - Created 

                    300-399         - Redirection 

                    400-499         - Client Errors 

                        404     - Not Found 

                    500-599         - Server errors 




        @PathVariable
            - used to bind a route parameter / path parameter with a variable 
            - http://localhost:8080/employees/101

        @RequestParam 
            - used to bind a query parameters with a variable
             http://localhost:8080/employees?city=Pune&salary=27700

        @RequestBody 
            - binds the request payload / request body with the specific java object/parameter
                 in the handler methods 

       
        Handle Exceptions 
        -------------------
            - local exceptional handler  
                using @ExceptionHander annotation inside the controller 

            - global exception handler 


        spring-boot-starter-validation 
        -----------------------------
            - it uses 'hibernate-validator' which allows us to validate java beans with a 
                few annotations as below 

            @NotNull 
            @NotEmpty 
            @NotBlank 
            @Email 
            @Size 
            @Pattern 
            

    Entity Class 
        - represents the data you want to persist in the database 

    DTO classes 
        - Data transfer object 
        - represents the request body or the response body 



    Entity 
        Product 

    DTOs 
        ProductDTO      -- represents the fields to be included in the response structure 
        ProductCreationDTO - represents the fields for creating a product 



        Employee                            Department 



        Order                               OrderItems                  Product 


        Post        1--------------------*      Comment 

        OneToMany                               ManyToOne



    Rest API Documentation 
    ---------------------------
        - using swagger 
        - using openAPI 
        - using Spring REST Docs 


    Spring Security 
    ------------------
        - Spring Security is a powerful and highly customizable authentication and access-control framework
        - Spring Security is a framework that focuses on providing both authentication and authorization to Java applications.

    - you can add the spring-security module to the existing spring boot project 
    	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>

    - after adding this dependency to the project, spring boot auto-configuration will automatically 
        configure "spring security beans" and enable the "default configuration" 
    
    Authentication 
        - is a user valid ? 

    Authorization 
        - define roles to perform some actions 
        - manage permissions 

    Standards in Authentication & Authorization
    --------------------------------------------
        - Basic HTTP Authentication
            - this is the default configuration in spring security 

        - OAuth 2.0 Login - OAuth 2.0 Log In with OpenID Connect and non-standard OAuth 2.0 Login (i.e. GitHub)

        - SAML 2.0 Login - SAML 2.0 Log In


      
        
    Authentication Providers 
    ---------------------------

    Auth-Servers 
    ---------------


    Authentication flows 
    ---------------------
        - client credentials flow  
        - password flow 
        - annonymous token flow 
        - refresh token flow 
        - 




    CSRF - cross site request forgery
    CORS 
    JWT & OAuth2
    Session Fixation 
    Brute Force 
    Stealing of data 
    fine grained security 
    users and roles 






    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





   
 